%% Generated by Sphinx.
\def\sphinxdocclass{jupyterBook}
\documentclass[a4paper,12pt,english]{jupyterBook}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax
\ifdefined\pdfimageresolution
    \pdfimageresolution= \numexpr \dimexpr1in\relax/\sphinxpxdimen\relax
\fi
%% let collapsible pdf bookmarks panel have high depth per default
\PassOptionsToPackage{bookmarksdepth=5}{hyperref}
%% turn off hyperref patch of \index as sphinx.xdy xindy module takes care of
%% suitable \hyperpage mark-up, working around hyperref-xindy incompatibility
\PassOptionsToPackage{hyperindex=false}{hyperref}
%% memoir class requires extra handling
\makeatletter\@ifclassloaded{memoir}
{\ifdefined\memhyperindexfalse\memhyperindexfalse\fi}{}\makeatother

\PassOptionsToPackage{warn}{textcomp}

\catcode`^^^^00a0\active\protected\def^^^^00a0{\leavevmode\nobreak\ }
\usepackage{cmap}
\usepackage{fontspec}
\defaultfontfeatures[\rmfamily,\sffamily,\ttfamily]{}
\usepackage{amsmath,amssymb,amstext}
\usepackage{polyglossia}
\setmainlanguage{english}



\setmainfont{FreeSerif}[
  Extension      = .otf,
  UprightFont    = *,
  ItalicFont     = *Italic,
  BoldFont       = *Bold,
  BoldItalicFont = *BoldItalic
]
\setsansfont{FreeSans}[
  Extension      = .otf,
  UprightFont    = *,
  ItalicFont     = *Oblique,
  BoldFont       = *Bold,
  BoldItalicFont = *BoldOblique,
]
\setmonofont{FreeMono}[
  Extension      = .otf,
  UprightFont    = *,
  ItalicFont     = *Oblique,
  BoldFont       = *Bold,
  BoldItalicFont = *BoldOblique,
]



\usepackage[Bjarne]{fncychap}
\usepackage[,numfigreset=1,mathnumfig]{sphinx}

\fvset{fontsize=\small}
\usepackage{geometry}
\usepackage{nicefrac, xfrac}


% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}


\usepackage{sphinxmessages}



        % Start of preamble defined in sphinx-jupyterbook-latex %
         \usepackage[Latin,Greek]{ucharclasses}
        \usepackage{unicode-math}
        % fixing title of the toc
        \addto\captionsenglish{\renewcommand{\contentsname}{Contents}}
        \hypersetup{
            pdfencoding=auto,
            psdextra
        }
        % End of preamble defined in sphinx-jupyterbook-latex %
        

\title{Technology}
\date{Jun 09, 2023}
\release{}
\author{Zuzanna Wieczorek, Grzegorz Gruszczyński}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{}
\makeindex
\begin{document}

\pagestyle{empty}
\sphinxmaketitle
\clearpage

\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{chapters/description/technology::doc}}


\sphinxAtStartPar
The main purpose of the thesis was to optimize the existing code for initial sail analysis.
Orginally the code was implementing many panel objects. Each one of them had many atributes like panel cooridinates, force, pressure, pressure coefficient, span and normal vector. When the size of lattice was increasing, the huge number of objects inside pySailingVLM slowed down the program. To optimize code, the Numba \sphinxhyphen{} JIT compiler that translates Python code and NumPy into machine code which enable parallel coalcuations, was applied. Becouse Numba do not understand custom objects like panel, the code was rewritten using two memory layout approaches.


\part{Memory layout}
\label{\detokenize{chapters/description/technology:memory-layout}}
\sphinxAtStartPar
Array of Structures (AoS) and Structure of Arrays (SoA) are layouts arranging a sequence of records in memory. Structure of Arrays (SoA) layout splits elements of a record into separate units allowing access these elements in parallel. The AoS is the opposite layout in which data for different fields is interleaved. Comparison between conceptual layout and memory layout is shown on figure \hyperref[\detokenize{chapters/description/technology:id2}]{\ref{\detokenize{chapters/description/technology:id2}}}.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[height=300\sphinxpxdimen]{{memory_layout}.png}
\caption{Comparison of the Structure of Arrays (SoA) and Arrray of Structure (AoS). Figure 2 from {[}\hyperlink{cite.chapters/bibliography:id11}{PHW+13}{]}}\label{\detokenize{chapters/description/technology:id2}}\end{figure}

\sphinxAtStartPar
The AoS approach ensures that the five values \(a_i, b_i, c_i, d_i, e_i\) are
next to one another in memory, providing good cache utilisation. The SoA approach ensures that these values are split into five separate units, allowing access to corresponding elements in parallel {[}\hyperlink{cite.chapters/bibliography:id11}{PHW+13}{]}.

\sphinxAtStartPar
Simple values like pressure coefficients, forces, pressure acting on each panel were arranged into simple NumPy arrays (SoA). Panel coorditnates, span and normal vectors was rearranged into nested ones (AoS). Figure \hyperref[\detokenize{chapters/description/technology:uklad}]{\ref{\detokenize{chapters/description/technology:uklad}}} shows data layout implemented.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[height=600\sphinxpxdimen]{{panele.drawio}.png}
\caption{Data layout implemented in pySailingVLM. Figure created by author.}\label{\detokenize{chapters/description/technology:uklad}}\end{figure}


\part{Benchmarks}
\label{\detokenize{chapters/description/technology:benchmarks}}
\sphinxAtStartPar
To benchmark pySalingVLM, the time comparison tests were conducted. Three approaches was summaries in the table \hyperref[\detokenize{chapters/description/technology:benchs}]{\ref{\detokenize{chapters/description/technology:benchs}}}: objective code, ‘non\sphinxhyphen{}objective’,  objective with Numba and ‘non\sphinxhyphen{}objective’ compiled with Numba.  The tests were carried out on a laptop with the following parameters: AMD Ryzen 7 4800H with 8 CPU cores (16 threads), base clock: 2.9 GHz, max boost: 4.2GHz, 32 GB RAM. For 1600 panels more then thirty times acceleration was obtained.


\begin{savenotes}\sphinxattablestart
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{Time execution comparison between different approaches of implementing pySailingVLM depending on sail shape.}\label{\detokenize{chapters/description/technology:benchs}}
\sphinxaftertopcaption
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
No. panels
&\sphinxstyletheadfamily 
\sphinxAtStartPar
objective {[}s{]}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
‘non\sphinxhyphen{}objective’ {[}s{]}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
objective + Numba {[}s{]}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
‘non\sphinxhyphen{}objective’ + Numba {[}s{]}
\\
\hline
\sphinxAtStartPar
100
&
\sphinxAtStartPar
16.51
&
\sphinxAtStartPar
20.0
&
\sphinxAtStartPar
1.71
&
\sphinxAtStartPar
1.04
\\
\hline
\sphinxAtStartPar
400
&
\sphinxAtStartPar
269.13
&
\sphinxAtStartPar
301.39
&
\sphinxAtStartPar
21.81
&
\sphinxAtStartPar
10.41
\\
\hline
\sphinxAtStartPar
600
&
\sphinxAtStartPar
593.85
&
\sphinxAtStartPar
647.96
&
\sphinxAtStartPar
48.44
&
\sphinxAtStartPar
22.51
\\
\hline
\sphinxAtStartPar
1600
&
\sphinxAtStartPar
4325.78
&
\sphinxAtStartPar
4458.05
&
\sphinxAtStartPar
320.54
&
\sphinxAtStartPar
143.69
\\
\hline
\sphinxAtStartPar
2400
&
\sphinxAtStartPar
no data
&
\sphinxAtStartPar
no data
&
\sphinxAtStartPar
724.70
&
\sphinxAtStartPar
320.12
\\
\hline
\sphinxAtStartPar
3600
&
\sphinxAtStartPar
no data
&
\sphinxAtStartPar
no data
&
\sphinxAtStartPar
1653.52
&
\sphinxAtStartPar
706.62
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
According to time results, using Numba is much more efficient when applied to the ‘non\sphinxhyphen{}objective’ code. In order to explain such behaviour the SIMD term should be investigated.


\chapter{SIMD and vectorization}
\label{\detokenize{chapters/description/technology:simd-and-vectorization}}
\sphinxAtStartPar
SIMD stands for Single Instruction Multiple Data. Instead of performing a single instruction on every single data, SIMD uses wider data\sphinxhyphen{}width for similar computational operations {[}\hyperlink{cite.chapters/bibliography:id12}{AS20}{]}. A comparison between simple scalar operation and a SIMD computation is depicted in figure \hyperref[\detokenize{chapters/description/technology:simd-fig}]{\ref{\detokenize{chapters/description/technology:simd-fig}}}.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics[height=200\sphinxpxdimen]{{simd_fig}.png}
\caption{Simple scalar operation (a) and a SIMD computation (b). Figure 1 from {[}\hyperlink{cite.chapters/bibliography:id12}{AS20}{]}.}\label{\detokenize{chapters/description/technology:simd-fig}}\end{figure}

\sphinxAtStartPar
Vectorization with AOS in memory data layout requires multiple load/shuffle/insert or gather instructions. Because of the reduced CPU frequency in SIMD mode its improvements are not sufficient. Increase in vector width demands more instructions for vector construction. A properly aligned memory data layout for vectorization which Numba uses, needs Structure of Arrays (SOA). It provides SIMD compatible memory accesses and results in efficiency and speedup {[}\hyperlink{cite.chapters/bibliography:id13}{WP16}{]}.

\sphinxAtStartPar
Array of Structure memory layout is more appropirate when no vectorization is used because proessing data are next to one another in memory. As a consequence, ‘non\sphinxhyphen{}objective’ code without Numba is slower than objective one (table \hyperref[\detokenize{chapters/description/technology:benchs}]{\ref{\detokenize{chapters/description/technology:benchs}}}).


\part{Other improvements}
\label{\detokenize{chapters/description/technology:other-improvements}}
\sphinxAtStartPar
Apart from code optimizations, the pySailingVLM has gained more features. The possibility to calculate cambered sailis and visualize pressure coefficients on colormap was introduced. Code has been packaged and now is available at Python Package Index (PyPI). It can be run locally from command line or in a cloud using Jupyter Notebook. pySailingVLM can be executed in a user defined script, which make it easy to calculate and compare many sailing cases.







\renewcommand{\indexname}{Index}
\printindex
\end{document}